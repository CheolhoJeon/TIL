---
description: 올바른 타입 계층을 구성하는 원칙
---

# 서브클래싱과 서브타이핑

> **상속의 용도: 1. 타입 계층 구현 2. 코드 재사용**

* 상속의 첫 번째 용도는 <mark style="color:red;">**타입 계층을 구현**</mark>하는 것
  * 타입 계층 안에서
    * <mark style="color:red;">**부모 클래스는 일반적인 개념을 구현**</mark>
    * <mark style="color:red;">**자식 클래스는 특수한 개념을 구현**</mark>
  * 타입 계층의 관점에서
    * 부모 클래스는 자식 클래스의 일반화(generialization)
    * 자식 클래스는 부모 클래스의 특수화(specialization)\

* 두 번째 용도는 <mark style="color:red;">**코드 재사용**</mark>임
  * 부모 클래스의 코드를 재사용할 수 있음
  * 하지만 두 클래스 간의 강한 결합이 발생해 코드를 변경하기 어려움\

* 상속을 사용하는 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것이어야함
  * **재사용을 목표로 상속을 사용하면** 부모, 자식 클래스를 강하게 결합시킴
  * **타입 계층을 목표로 상속을 사용하면** 확장 가능하고 유연한 설계를 얻을 수 있음
* 단, 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야함

## 1. 타입

> **타입은 **<mark style="color:red;">**프로그래밍 언어 관점에서의 타입**</mark>**과 **<mark style="color:red;">**개념 관점에서의 타입**</mark>**으로 나누어 볼 수 있음**

### 1-1. 개념 관점의 타입

* 개념 관점에서 타입이란 우리가 인지하는 세상의 사물의 종류를 의미함
* 다시 말해, 우리가 인식하는 객체들에 적용하는 개념이나 아이디어를 가리켜 타입이라고 부름
* 예를 들어, 자바, 루비, C를 프로그래밍 언어라고 부를 때 우리는 이것들을 프로그래밍 언어라는 타입으로 분류\

* 어떤 대상이 타입으로 분류될 때 그 대상을 타입의 인스턴스(instance)라고 부름
* 일반적으로 타입의 인스턴스를 객체라고 부름

> **타입의 구성 요소: 심볼, 내연, 외연**

* <mark style="color:red;">**심볼(symbol)**</mark>
  * 타입에 이름을 붙인 것
  * 앞에서 '프로그래밍 언어'가 타입의 심볼에 해당함
* <mark style="color:red;">**내연(intension)**</mark>
  * 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킴
  * 타입에 속하는 객체들이 공유하는 속성과 행동의 집합이 내연을 구성함
* <mark style="color:red;">**외연(extension)**</mark>
  * 타입에 속하는 객체들의 집합
  * '프로그래밍 언어' 타입의 경우에는 자바, 루비, C가 속한 집합이 외연을 구성함

### 1-2. 프로그래밍 언어 관점의 타입

* 프로그래밍 언어 관점에서 타입은 비트에 의미를 부여하기 위해 정의된 '제약'과 '규칙'을 가리킴
* 비트에 담긴 데이터를 문자열로 다룰지, 정수로 다룰지는 데이터의 타입 의해 결정됨

프로그래밍 언어에서 타입은 두 가지 목적을 위해 사용됨

1.  타입에 수행될 수 있는 유효한 <mark style="color:red;">**오퍼레이션의 집합을 정의**</mark>한다

    '+' 연산자는 원시형 숫자 타입이나 문자열 타입의 객체에는 사용할 수 있지만 다른 클래스의 인스턴스에 대해서는 사용할 수 없음
2. 타입에 수행되는 오퍼레이션에 대해 미리 <mark style="color:red;">**약속된 문맥을 제공**</mark>한다.\
   '+' 연산자는 연산의 대상이 숫자 타입이면 '덧셈', 문자열 타입이면 '연결'을 수행함

> 타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지하기 위해 사용됨

### 1-3. 객체지향 패러다임 관점의 타입

* 위의 두 관점에서의 정의를 객체지향 패러다임 관점에서 조합해볼 수 있음
* OOP에서 오퍼레이션은 객체가 수신할 수 있는 메시지를 의미함
* 따라서 OOP에서 타입을 정의하는 것은 <mark style="color:red;">**객체의 '퍼블릭 인터페이스'를 정의하는 것과 동일함**</mark>
  * 퍼블릭 인터페이스만이 메시지라고 불릴 수 있음
* **OOP에서는 객체가 수신할 수 있는 메시지를 기준으로 타입을 분류하기 때문에 동일한 인터페이스를 가지는 객체들은 동일한 타입으로 분류할 수 있음**\

* 타입의 정의는 _**객체에게 중요한 것은 속성이 아니라 행동이라는 사실**_을 다시 한번 강조함
* **어떤 객체들이 동일한 상태를 가지고 있더라도 퍼블릭 인터페이스가 다르다면 서로 다른 타입으로 분류됨**
* 객체의 타입을 결정하는 것은 내부 속성이 아니라 객체가 외부에 제공하는 행동임



## 2. 타입 계층

***

### 2-1. 타입 사이의 포함관계

* 타입은 객체들의 집합이기 때문에 **다른 타입을 포함하는 것이 가능함**
* 타입 안에 포함된 객체들을 좀 **더 상세한 기준으로 묶어 새로운 타입을 정의**하면 이 새로운 타입은 자연스럽게 기존 **타입의 부분집합**이 됨

![프로그래밍 언어 타입의 인스턴스 집합](../../.gitbook/assets/Untitled-58.png) ![타입은 공통적인 특성을 가진 객체들을 포함하는 집합이다](<../../.gitbook/assets/Untitled-59 (1).png>)

* 타입이 다른 타입에 포함될 수 있기 때문에 동일한 <mark style="color:red;">**인스턴스가 하나 이상의 타입으로 분류되는 것도 가능함**</mark>
* 자바는 '프로그래밍 언어'인 동시에 '객체지향 언어'에 속하며 더 세부적으로 '클래스 기반 언어' 타입에 속함
* **다른 타입을 포함하는 타입은 포함되는 타입보다 좀 더 일반화된 의미를 표현함**
* **반면 포함되는 타입은 좀 더 특수하고 구체적임**\

* 다시 말해, 포함하는 타입은 외연 관점에서는 더 크고 내연 관점에서는 더 일반적임
* 이와 반대로 포함되는 타입은 외연 관점에서는 다 작고 내연 관점에서는 더 특수함\

* 아래와 같이 특수화 관계를 가진 계층으로 표현할 수 있음
* 타입 계층을 표현할 때는 더 일반적인 타입을 위쪽에, 더 특수한 타입을 아래쪽에 배치하는 것이 관례임
* 타입 계층을 구성하는 두 타입 간의 관계에서
  * 더 일반적인 타입을 <mark style="color:red;">**슈퍼타입(supertype)**</mark>이라고 부르고
  * 더 특수한 타입을 <mark style="color:red;">**서브타입(subtype)**</mark>이라고 부름

![일반화/특수화 관계로 연결된 타입 계층](../../.gitbook/assets/Untitled-60.png)

> 내연과 외연의 관점에서 서브타입과 슈터타입을 다음과 같이 정의할 수 있음

1. 슈퍼타입은
   * 집합이 다른 집합의 모든 멤버를 포함한다.
   * 타입 정의가 다른 타입보다 좀 더 일반적이다.
2. 서브타입은
   * 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
   * 타입 정의가 다른 타입보다 좀 더 구체적이다.

{% hint style="info" %}
슈퍼타입과 서브타입이라는 용어는 슈퍼셋과 서브셋으로부터 유래한 것
{% endhint %}

### 2-2. 객체지향 프로그래밍과 타입 계층

* 객체의 타입을 결정하는 것은 퍼블릭 인터페이스임
* 타입 계층 간의 관계를 형성하는 기준 또한 '퍼블릭 인터페이스'
* 더 일반적인 퍼블릭 인터페이스를 가지는 객체들은 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 슈퍼타입

> **서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다. 이 사실이 상속과 다형성의 관계를 이해하기 위한 출발점이다.**



