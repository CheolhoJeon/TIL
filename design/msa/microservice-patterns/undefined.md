# 마이크로서비스 쿼리 구현

* 마이크로서비스로 전환 시 고민해야 할 분산 데이터 관련 문제가 트랜잭션만 있는 것은 아님
* 쿼리를 구현하는 방법도 찾아내야함



* DB가 하나뿐인 모놀리식 애플리케이션에서는 비교적 쉽게 쿼리를 구현했음
* 개발자가 할 일은 SELECT 문을 작성하고 필요한 인덱스를 정의하는 작업 정도였음
* 하지만 마이크로서비스에서는 여러 서비스, 여러 DB에 분산된 데이터를 조회해야함
* 기존 분산 쿼리 메커니즘(?)은 기술적으로 가능하다 해도 캡슐화에 위배되기 때문에 사용할 수 없음



* 마이크로서비스 아키텍처에서는 다음 두 가지 패턴으로 쿼리를 구현함
* <mark style="color:blue;">**API 조합 패턴(API Composition Pattern)**</mark>: 서비스 클라이언트가 데이터를 가진 여러 서비스를 직접 호출하여 그 결과를 조합하는 패턴. 가장 단순한 방법으로 가급적 이 방법을 쓰는 것이 좋음
* <mark style="color:blue;">**CQRS 패턴(Command Query Responsibility Segregation)**</mark>: 쿼리만 지원하는 하나 이상의 뷰 전용 DB를 유지하는 패턴. API 조합 패턴보다 강력한 만큼 구현하기는 더 복잡함

## 1. API 조합 패턴

> 본 절에서는 여러 서비스에 있는 데이터를 조회하는 쿼리를 구현할 때 어떤 문제점이 있는지, API 조합 패턴을 어떻게 구현해야하는지 기술함

### 1.1 여러 서비스에 걸친 쿼리

* `findOrder()`는 기본키로 주문 정보를 조회하는 메서드이며, `orderId`를 매개변수로 받아 주문 내역이 포함된 `OrderDetails` 객체를 반환함
* 모바일 기기 또는 웹 애플리케이션 등의 프론트엔드 모듈(frontend module)이 이 메서드를 호출함
* 주문과 관련된 데이터가 여러 서비스에 흩어져 있으므로, 모든 서비스에 요청을 해야함

![](<../../../.gitbook/assets/Screen Shot 2022-02-08 at 10.30.01 AM.png>)

### 1.2 API 조합 패턴 개요

* API 조합 패턴은 API 조합기와 둘 이상의 프로바이더 서비스로 구성됨
  * <mark style="color:blue;">**API 조합기(API composer)**</mark>: 프로바이더 서비스를 쿼리하여 데이터를 조회함. 웹 페이지에 데이터를 렌더링 하는 클라이언트, API 게이트웨어, 프론트엔드를 위한 백엔드 패턴의 변형일 수도 있음
  * <mark style="color:blue;">**프로바이더 서비스(provider service)**</mark>: 최종 결과로 반환할 데이터의 일부를 가지고 있는 서비스
* API 조합기는 프로바이더를 쿼리해서 반환된 결과를 조합함

![](<../../../.gitbook/assets/Screen Shot 2022-02-08 at 10.52.10 AM.png>)

### 1.3 API를 조합 패턴으로 쿼리 구현

* `findOrder()`는 단순히 기본키로 EQUI 조인해서 쿼리하는 작업임
* `orderId`로 필요한 데이터를 가져올 수 있는 API 끝점은 각 프로바이더 서비스가 당연히 제공하리라 볼 수 있기 때문에 API 조합 패턴으로 구현하기에 제격임

![](<../../../.gitbook/assets/Screen Shot 2022-02-08 at 11.00.13 AM.png>)

* 여기서 API 조합기는 쿼리를 REST 끝점으로 표출한 서비스임
* HTTP 대신 gRPC 같은 다른 IPC 프로토콜을 사용하는 서비스 역시 개념은 같음
* 주문 검색 조합기는 `orderId`로 네 서비스를 호출한 후 수신한 응답을 조인함

### 1.4 API 조합 설계 이슈

* API 조합 패턴에는 다음 두 가지 설계 이슈가 있음
  * 어느 컴포넌트를 쿼리 작업의 API 조합기로 선정할 것인가?
  * 어떻게 해야 효율적으로 취합 로직을 작성할 것인가?

#### 누가 API 조합기 역할을 맡을 것인가?

API 조합기 역할을 누가 맡을지 선택하는데 있어, 세 가지 옵션이 있음

{% tabs %}
{% tab title="클라이언트에 적용" %}
* 주문 상태 뷰를 구현한 웹 애플리케이션 같은 클라이언트가 동일한 LAN에서 실행 중이라면 가장 효율적으로 주문 내역을 조회할 수 있음
* 하지만 클라이언트가 방화벽 외부에 있고 서비스가 위치한 네트워크가 느리다면 그리 실용적이지 않음

![](<../../../.gitbook/assets/Screen Shot 2022-02-08 at 11.26.26 AM (1).png>)
{% endtab %}

{% tab title="API 게이트웨이에 적용" %}
* 쿼리 작업이 작업이 애플리케이션의 외부 API 중 일부라면 이 방법이 타당함
* 다른 서비스(=스탠드얼론 서비스)로 요청을 보내는 대신 차라리 API 게이트웨이에 API 조합 로직을 구현하는 것
* 모바일 기기 등 방화벽 외부에서 접근하는 클라이언트가 API 호출 한 번으로 여러 서비스의 데이터를 조회할 수 있기 때문에 효율적임

![](<../../../.gitbook/assets/Screen Shot 2022-02-08 at 11.27.48 AM.png>)
{% endtab %}

{% tab title="스탠드얼론 서비스에 적용" %}
* 내부적으로 여러 서비스가 사용하는 쿼리 작업이라면 좋은 방법임
* 취합 로직이 너무 복잡해서 API 게이트웨이 일부로 만들기는 곤란하고, 외부에서 접근 가능한 쿼리 작업을 구현할 경우에도 좋은 방법임

![](<../../../.gitbook/assets/Screen Shot 2022-02-08 at 11.32.03 AM.png>)
{% endtab %}
{% endtabs %}

#### API 조합기는 리액티브 프로그래밍 모델을 사용해야 한다

* 분산 시스템을 개발할 때 지연 시간을 최소화하는 문제는 항상 골칫거리임
* 쿼리의 응답 시간을 최대한 줄이려면 가능한 한 API 조합기가 프로바이더 서비스를 병렬 호출해야함
* 하지만 어떤 프로바이더 서비스를 호출하기 위해 다른 프로바이더 서비스의 결과를 먼저 가져와야하는 경우도 있음
* 이때는 일부 프로바이더 서비스를 순차 호출해야함



* 그러나 순차/병렬 서비스 호출이 뒤섞인 실행 로직은 복잡해질 수 있음
* <mark style="color:blue;">**관리가 용이하고 성능/확장성이 우수한 API 조합기를 작성하려면 리액티브 설계 기법을 동원해야함**</mark>
  * Ex) CompleteFuture, RxJava, 또는 이와 동등한 추상체

### 1.5 API 조합 패턴의 장단점

API 조합 패턴은 마이크로서비스 아키텍처에서 아주 쉽고 단순하게 쿼리 작업을 구현할 수 있게 해주지만, 다음과 같은 단점도 있음:

{% tabs %}
{% tab title="오버헤드가 증가한다" %}
* 여러 서비스를 호출하고 여러 DB를 쿼리하는 오버헤드는 불가피함
* 모놀리식에서는 클라이언트가 요청 한 번으로, 그것도 대부분 DB 쿼리문 하나로 필요한 데이터를 조회함
* 하지만 API 조합 패턴은 여러번 요청하고 여러 DB 쿼리를 실행해야함
* 따라서 그만큼 컴퓨팅/네트워크 리소스가 더 많이 소모되고 애플리케이션 운영 비용도 늘어남
{% endtab %}

{% tab title="가용성이 저하될 우려가 있다" %}
* 어떤 작업의 가용성은 더 많은 서비스가 개입할수록 감소함
* 하나의 쿼리 작업에 최소한 세 서비스가 반드시 개입되는 구조라서 하나의 서비스로 처리하는 것에 비해 가용성은 현저히 낮음
* 각 서비스의 가용성이 99.5%이면, 프로바이더 서비스 4개를 호출하는 요청의 가용성은 97.5%가됨



{% hint style="info" %}
<mark style="color:blue;">**가용성을 높이는 전략으로 두 가지**</mark>

첫째, 프로바이더 서비스가 불능일 경우 API 조합기가 이전에 캐시한 데이터를 반환하는 것

* 성능 향상을 목적으로 API 조합기에 캐시된, 프로바이더 서비스의 반환 데이터를 잘 활용하면 가용성을 향상시킬 수 있음
* 프로바이더 서비스가 내려가더라도 API 조합기는(오래 되어 맞지 않는 데이터도 있겠지만) 캐시 데이터를 반환할 수 있음

둘째, API 조합기가 미완성된 데이터를 반환하는 것

* 가령 주방 서비스가 일시 불능 상태가 되면, 주문 검색 조합기가 이 서비스의 데이터만 제외한 나머지 데이터를 반환함
* 특정 데이터가 없어도 UI에서 유용한 정보를 표시하는 데에 별 지장이 없는 경우 활용할 수 있음
{% endhint %}
{% endtab %}

{% tab title="데이터 일관성이 결여된다" %}
* 모놀리식 애플리케이션은 대부분 한 트랜잭션으로 쿼리를 수행함
* ACID 트랜잭션은 애플리케이션이 여러 DB 쿼리를 실행해도 데이터를 일관되게 바라볼 수 있게 보장함
* <mark style="color:blue;">**그러나 API 조합 패턴은 여러 DB를 대상으로 여러 쿼리를 실행하기 때문에 일관되지 않은 데이터가 반환될 수있음**</mark>
{% endtab %}
{% endtabs %}

* 이런 단점에도 API 조합 패턴은 꽤 많은 쿼리 기능을 쉽게 구현할 수 있는 수단으로 아주 유용함
* 하지만 효율적으로 구현하기 어려운 (가령 거대한 데이터 뭉치를 인-메모리 조인하는) 쿼리 작업은 CQRS 패턴으로 구현하는 편이 바람직함

## 2. CQRS 패턴
