---
description: CQRS 패턴을 처음으로 소개한 Greg Young의 CQRS Document
---

# CQRS Documents by Greg Young

## 1. A Stereotypical Architecture

도메인 주도 설계 기반 프로젝트의 아키텍처를 살펴보기 전에, 일반적으로 많은 사람들이 프로젝트에 적용하려고하는 표준 아키텍처가 무엇인지 분석할 필요가 있습니다. 이를 통해 생산성 측면의 비용을 최소화하면서 전통적인 아키텍처를 더 나은 아키텍처로 개선할 수 있습니다.

아래의 그림은 전통적인 아키텍처를 보여줍니다.

![\[그림 1\] A stereotypical Architecture](<../../.gitbook/assets/Screen Shot 2022-02-03 at 9.14.22 PM.png>)

### 1-1. Application Server

위의 아키텍처는 백업 저장소 시스템을 중심으로 구성되었습니다. 데이터 저장소는 일반적으로 RDBMS이지만 [키-값 데이터베이스](https://en.wikipedia.org/wiki/Key-value\_database), [객체 지향 데이터베이스](https://en.wikipedia.org/wiki/Object\_database), XML 파일이 될 수도 있습니다. 여기서 중요한 점은 백업 저장소가 도메인 객체의 현재 상태를 나타낸다는 것입니다.

백업 저장소는 애플리케이션 서버 위에 위치합니다. \[그림 1]에서 도메인으로 표시된 논리 영역은 시스템의 비즈니스 로직을 담당합니다. 애플리케이션 서버에게 전달된 요청을 처리하기 위한 유효성 검사 및 오케스트레이션 로직(orchestration logic)이 이 영역에서 처리됩니다.

_\[그림 1]에서는 데이터 계층(data tier)이 표현되지 않았지만 애플리케이션 서버와 데이터 저장소 사이에 데이터 계층이 존재할 수 있다는 점에 유의해야합니다. 또한 이 아키텍처를 구현하는데 도메인 영역이 필수 사항은 아니며_ [_테이블 모듈(Table Module)_](https://martinfowler.com/eaaCatalog/tableModule.html)_이나_ [_트랜잭션 스크립트(Transaction Script)_](https://martinfowler.com/eaaCatalog/transactionScript.html)_와 같은 패턴을 사용할 수도 있다는 점도 중요합니다. 이것들은_ 애플리케이션 서비스(_Application Services)로서 존재합니다._

"도메인"을 추상화하면 애플리케이션 서비스로 알려진 파사드(facade)을 찾을 수 있습니다. 애플리케이션 서비스는 도메인 및 데이터와의 인터페이스 역할을 하며, 도메인 소비자와 도메인 간의 결합을 줄여줍니다.

애플리케이션 서버 바깥 쪽에는 여러 종류의 원격 파사드(Remote Facade)를 확인 할 수 있습니다. 원격 파사드는 SOAP, 커스텀된 TCP/IP, HTTP를 통한 XML, 톰캣 심지어 비둘기 다리에 매달은 쪽지가 될 수도 있습니다. 원격 파사드는 관련된 상황과 도구에 따라 기본 기술 메커니즘에서 추상화될 수도 있고 그렇지 않을 수도 있습니다.

시스템의 데이터 저장소를 추상화하고 비즈니스 로직을 집중시키기 위해, 애플리케이션 서버는 여러해 동안 매우 인기가 높았으며 많은 시스템에 기본 아키텍처로서 적용되왔습니다.

### 1-2. Client Interaction

클라이언트의 일반적인 상호작용은 \[그림 2]에서 살펴 볼 수 있습니다.

![\[그림 2\] Typical Client Interaction](<../../.gitbook/assets/Screen Shot 2022-02-03 at 9.15.37 PM.png>)

클라이언트의 기본적인 상호작용은 DTO(Data Transfer Object)의 상/하 상호작용으로 설명할 수 있습니다. 작업의 수명주기를 살펴 보면 API의 기능을 쉽게 이해할 수 있습니다. 화면을 통해 사용자의 정보를 수정한다고 가정해봅시다. 먼저 클라이언트는 사용자의 id를 담은 DTO를 포함한 요청을 원격 파사드로 보냅니다. 원격 파사드는 응답에 필요한 도메인 객체를 로드하고 도메인 객체를 DTO에 매핑한 다음 클라이언트에 반환합니다. \[그림 3]은 XML 형식의 DTO 예제를 보여줍니다. 여기서 전통적인 아키텍처에서 DTO는 클라이언트의 요청에 필요한 객체의 현재 상태를 저장하고 있음을 인지해야합니다.

이 후, 클라이언트는 원격 파사드로 부터 수신한 정보를 화면에 표시하여 사용자가 상호 작용할 수 있게끔 합니다. This is very often done utilizing a view model and/or data binding with the view.

특정 시점에서 사용자는 화면(UI)을 통해 데이터 편집을 완료하고 데이터를 저장하게 됩니다. 일반적으로 저장 버튼을 통해 구현되만 일부 사용자 인터페이스는 현재 데이터를 강제적으로 저장하는 경우도 있습니다.

![\[그림 3\] Example in XML of a DTO](<../../.gitbook/assets/Screen Shot 2022-02-03 at 9.17.46 PM.png>)

클라이언트는 데이터를 저장하기 위해 사용자가 화면에서 편집한 데이터를 DTO로 옮깁니다. 일반적으로 사용자에게 표시하기 위해 원격 파사드에서 요청한 DTO와 동일합니다. 이 후 클라이언트는 애플리케이션 서버로 완성한 DTO를 전송합니다.

DTO를 수신한 애플리케이션 서버는 트랜잭션 및 세션을 시작한 후, DTO를 다시 도메인 객체로 변환하고 변경사항을 도메인 객체가 검증하게 합니다. 이후 ORM과 같이 도메인 객체의 변경 사항을 구별하여 데이터 저장소에 적절히 변경 분을 반영할 수 있는 도구를 활용하여 도메인 객체 내부의 변경사항을 데이터 저장소에 다시 반영합니다. 작업을 마친 애플리케이션 서버는 변경이 완료 되었다는 정보 또는 변경 실패의 이유에 대한 에러 메세지를 Ack를 통해 클라이언트에게 전송합니다.

### 1-3. Analysis of the Stereotypical Architecture

모든 아키텍처와 마찬가지로 위에서 언급한 아키텍처는 여러 특성을 가지고 있습니다. 몇몇 특성은 특정 시나리오에 대해 적합할 수 있으나 다른 시나리오에 대해서 매우 나쁠 수 있습니다. 설계자로서 우리는 요구사항에 대해 가장 적합한 특성을 활용하기 위해 노력해야합니다.

## 원문

[CQRS Documents by Greg Young](https://cqrs.files.wordpress.com/2010/11/cqrs\_documents.pdf)
