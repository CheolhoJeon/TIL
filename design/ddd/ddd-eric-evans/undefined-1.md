# 소프트웨어에서 표현되는 모델

## 4. 서비스(SERVICE)

> 때로는 우리가 다뤄야하는 도메인이 'Thing'이 아니다. \
> 'Thing'에 속하지 않는 도메인 개념은 어떻게 다뤄야 할까?

* 매우 명확하고 실용적인 설계에서도 개념적으로 특정 객체에 속하지 않는 연산이 존재할 수 있음
* 문제 영역의 자연스러운 형태에 따라 모델에 <mark style="color:red;">**서비스(SERVICES)**</mark>를 포함할 수 있음\

* 엔터티(ENTITY)나 값 객체(VALUE OBJECT)에 속하지 못하는 중요한 도메인 연산이 있을 수 있음
* 이들 중 일부는 본질적으로 사물이 아닌 활동(activity)이나 행동(action)인데, 객체 모델링 패러다임이더라도 그러한 연산을 객체와 잘 어울리게끔 해야함\

* 행위를 적절한 객체로 다듬지 못하게 되면 절차적 프로그래밍에 빠질 수 있음
* 하지만 객체의 정의에 어울리지 않는 연산을 강제로 객체에 포함시킨다면 해당 객체는 자신의 개념적 명확성을 잃어버릴 수 있음
  * 이해하거나 리팩터링하기 어려워짐
* 복잡한 작업은 종종 여러 도메인 객체를 한데 모아 실행하기 때문에, 객체 간의 의존을 만들고 독립적으로 이해하기 어렵게 만들 수 있음
  * 각 객체의 역할이 흐려질 수 있음\

* 때로는 서비스가 모델 객체로 가장하여, 일부 작업을 수행하는 것 외에는 의미가 없는 객체로 나타남
* 이 같은 ‘행위자(doer)’는 이름 끝에 ‘Manager’와 같은 명칭이 붙음
* 행위자는 상태를 가지지 않으며, 오퍼레이션 제외하고는 도메인에서 어떠한 의미도 가지지 않음
* 그럼에도 이러한 해법은 모델 객체를 어지럽히지 않으면서 뚜렷이 구분되는 행위의 근거지를 만들어 줌\

* **도메인 개념 중에 객체로는 모델에 어울리지 않는 것들이 있음**
* **필요한 도메인 기능을 엔터티나 값 객체에 억지로 맡기면 모델에 기반을 둔 객체의 정의가 왜곡되거나, 또는 무의미하고 인위적인 객체가 만들어질 것임**\
  ****
* 서비스는 모델과 독립적인 인터페이스를 제공하는 오퍼레이션이며, 엔터티 그리고 값 객체와 달리 상태를 캡슐화하지 않음
* 몇몇 프레임워크에서 서비스는 흔히 사용되는 패턴이지만, **도메인 계층에서도 사용될 수 있음**\
  ****
* 서비스는 엔터티나 값 객체와 다르게 순수히 클라이언트에게 어떤 것을 제공할는 수 있냐는 관점에서 정의됨
* 서비스는 엔터티(entity)라기 보다는 활동(activity), 즉 명사 보다는 동사로 명명되는 경향이 있음
* 서비스의 책임과 해당 책임을 이행하는 인터페이스는 도메인 모델의 일부임
* 연산의 명칭은 유비쿼터스 언어에서 유래하거나 유비쿼터스 언어에 도입돼야 함
* **또한 서비스의 매개변수와 결과는 도메인 객체여야함**\
  ****
* 잘 만들어진 서비스는 아래의 세 가지 특징이 있음:
  1. 오퍼레이션이 원래부터 엔터티나 값 객체의 일부가 아닌 도메인 개념과 관련돼 있음
  2. 인터페이스가 도메인 모델의 다른 요소 관점에서 정의됨
     * The interface is defined in terms of other elements of the domain model.
  3. 오퍼레이션이 상태를 갖지 않음\

* **도메인의 중대한 프로세스나 변환 과정이 엔터티나 값 객체의 고유한 책임이 아니라면, 오퍼레이션을 모델에 독립된 인터페이스인 서비스로서 추가해야함**
* **모델의 언어라는 측면에서 인터페이스를 정의하고 오퍼레이션의 이름을 유비쿼터스 언어의 일부가 되게끔 구성해야함**
* **서비스는 상태를 가지 않게 만들어야함**

### 4-1. 서비스와 격리된 도메인 계층

* 지금까지 도메인에서 중요한 의미를 지닌 서비스에 초점을 맞추곤 있지만, 서비스는 도메인 계층에서만 사용되는 것은 아님
* **도메인 계층에 속하는 서비스와 다른 계층에 속하는 것들을 구분하고, 그러한 구분을 명확하게 유지하기 위한 책임을 나누는데 주의를 기울여야함**\
  ****
* 대부분의 서비스는 기술적(technical)이며 인프라스트럭처 계층에 속함
* 도메인 서비스와 응용 서비스는 인프라스트럭처 서비스와 협업함
* 예를 들어 은행에서 계좌 잔고가 일정 금액 아래로 떨어지면 고객에게 이메일을 발송하는 애플리케이션이 있다고 가정해보자
* 이때 이메일 시스템과 통지 수단을 캡슐화하는 인터페이스는 인프라스트럭처 서비스에 해당함\

* 응용 서비스와 도메인 서비스를 구분하는 것은 더 어려울 수 있음
* 응용 계층은 통지를 관리할 책임이 있음
* 도메인 계층은 계좌 잔고가 일정 금액에 도달했는지 판단할 책임이 있음
  * 이러한 책임은 ‘계좌’ 객체의 책임에 어울리기 때문\

* 뱅킹 애플리케이션은 자금 이체를 책임질 수도 있음
* 이체에 대한 입출금 승인을 서비스에서 수행하게 되었다면, 해당 기능은 도메인 계층에 속할 것임
* 자금 이체는 업무 도메인에서 의미가 있으며, 중요한 업무 규칙을 포함함
* 기술과 관련된 서비스에는 업무와 관련된 어떤 것도 포함돼서는 안됌

> 서비스를 여러 계층으로 분할하기

{% tabs %}
{% tab title="응용" %}
자금 이체 응용 서비스

* 입력(XML 요청과 같은) 내용의 암호화
* 이체 처리를 위한 도메인 서비스로의 메시지 전송
* 이체 확인 대기
* 인프라스트럭처 서비스를 이용한 통지 결정
{% endtab %}

{% tab title="도메인" %}
자금 이체 도메인 서비스

* 금액 인출/입금에 필요한 ‘계좌’와 ‘원장’ 객체 간의 상호작용
* 이체 결과 확인 정보 제공
{% endtab %}

{% tab title="인프라스트럭처" %}
통지 서비스

* 애플리케이션에서 지정한 곳으로 이메일이나 우편 등을 보냄
{% endtab %}
{% endtabs %}

### 4-2. 구성 단위

* 지금까지 개념을 서비스로 모델링할 때의 표현력에 비중을 두었지만,
* 이 패턴은 엔터티와 값 객체로 부터 클라이언트를 분리하는 것과 더불어 도메인 계층의 인터페이스 구성 단위를 제어하는 수단으로서도 매우 가치가 있음\

* 구성 단위가 중간 크기(medium-grained)인 서비스는 대형 시스템에서 재사용하기 더 쉬울 수 있음
* 그 이유는 간단한 인터페이스 뒤에 상당한 기능을 캡슐화하고 있기 떄문임
* 아울러 구성 단위가 세밀한(fine-grained) 객체는 분산 시스템에서 비효율적인 메시지 전송을 초래할 수 있음\

* **앞서 논의한 바와 같이 구성 단위가 세밀한 도메인 객체는 도메인에서 지식이 새어 나오게 해서 도메인 객체의 행위를 조정하는 응용 계층으로 흘러가게 할 수 있음**
* **그렇게 되면 고도로 세분화된 상호작용의 복잡성이 결국 응용 계층에서 처리되고, 도메인 계층에서 새어나간 도메인 지식이 응용 계층의 코드나 사용자 인터페이스 계층의 코드로 스며들게 됨**
* **도메인 서비스를 적절히 도입하면 계층 간의 경계를 선명하게 하는 데 도움이 될 수 있음**\
  ****
* 이 패턴은 클라이언트 제어와 융통성보다는 인터페이스의 단순함을 선호함
* 이는 대형 시스템이나 분산 시스템에서 컴포넌트를 패키지화하는 데 매우 유용한 중간 구성 단위의 기능성을 제공함
* 그리고 때로는 서비스가 도메인 개념을 표현하는 가장 자연스러운 방법이기도 함

## 5. 모듈(MODULE)

> 모듈, 패키지라고도 함

* 모듈(Module)은 오래 전부터 확립되어 사용되고 있는 설계 요소임
* 모듈화의 가장 주된 이유는 바로 [인지적 과부화(cognitive overload)](https://en.wikipedia.org/wiki/Cognitive\_load)임
* <mark style="color:red;">**개발자는 모듈을 토대로 모델을 두 가지 측면에서 바라볼 수 있음**</mark>
  * 전체에 압도되지 않고 모듈에 들어 있는 세부사항을 살펴볼 수 있음
  * 모듈에 세부사항을 배제한 상태에서 모듈 간의 관계를 볼 수 있음
* 도메인 계층의 모듈은 모델의 중요한 요소로 나타나 도메인의 주요한 스토리를 전해야만 함\

* 모든 사람들이 모듈을 사용하지만 그 중에서 모듈을 하나의 완전한 자격을 갖춘 모델 요소로 여기는 사람은 거의 없음
* 코드는 기술적 아키텍처에서 개발자에게 할당된 작업까지 온갖 범주의 것으로 나뉨
* 그러나 리팩터링을 많이 하는 개발자도 프로젝트 초기에 생각해낸 모듈에 만족하는 경향이 있음\

* 모듈 간에는 결합도가 낮아야 하고 모듈의 내부는 응집도가 높아야 한다는 것은 자명한 사실임
* 결합도와 응집도에 대한 설명은 그것을 기술적인 측정 기준처럼 들리게 해서 결합도와 응집도의 정도를 기계적으로 판단하게 만듬
* **그러나 모듈로 쪼개지는 것은 코드가 아닌 바로 개념임**
* <mark style="color:red;">**어떤 사람이 한 번에 생각해낼 수 있는 양에는 한계가 있으며(따라서 결합도는 낮춰야 함), 일관성이 없는 단편적인 생각은 획일적인 생각을 섞어 놓은 것처럼 이해하기 어려움(따라서 응집도는 높여야 함)**</mark>\
  ****
* 낮은 결합도와 높은 응집도는 개별 객체에서와 마찬가지로 모듈에도 적용되는 일반적인 설계 원칙임
* 이 원칙은 구성 단위가 큰 모델링과 설계에서는 특히 중요함\

* 모듈과 좀 더 규모가 작은 요소들은 함께 발전해야 하지만 대개 그렇게 되지 않음
* 모듈은 객체의 초기 형태를 조직화할 목적으로 사용됨
* 그러고 나면 객체는 기존 모듈이 정의함 범위 안에 머무를 수 있는 방식으로 변화함
* 모듈을 리팩터링하는 것은 클래스를 리팩터링하는 것보다 일이 더 많고 파급효과가 더 크며, 아마도 자주 하기는 힘들 것임
* 그러나 모델 객체가 원시적이고 구체적인 상태에서 시작해서 점차 변형되어 더욱 심층적인 통찰력을 드러내는 것 처럼 모듈도 명석하고 추상적인 형태로 변화할 수 있음
* 도메인을 이해하는 바가 바뀔 때마다 이를 모듈에도 반영하면 모듈 안의 객체도 더 자유롭게 발전할 수 있음\

* 도메인 주도 설계의 다른 모든 것들과 마찬가지로 모듈도 하나의 **의사소통 매커니즘임**
* 분할된 객체의 의미에 따라 모듈을 선택해야함
* **어떤 클래스들을 한 모듈 안에 함께 둔다면, 그것은 옆에서 설계를 살펴보는 동료 개발자에게 그 클래스들을 하나로 묶어서 생각하자고 말하는 것과 같음**
* 모델이 어떤 이야기를 들려주는 것이라면, 모듈은 이야기의 각 ‘장’에 해당함
* 모듈의 이름은 모듈의 의미를 전해주며, 이 이름은 유비쿼터스 언어에 포함됨\

* **시스템의 스토리를 말해주는 모듈을 선정해 일련의 응집력 있는 개념들을 해당 모듈에 담아야함**
* **이렇게 하면 종종 모듈 간의 결합도가 낮아지기도 하는데 그렇게 되지 않는다면**
  * **모델을 변경함으로써 얽혀 있는 개념을 풀어내야함**
  * **모델의 각 요소를 맺어줄 수 있는 모듈의 기준 중 놓친 개념이 있는 지 찾아봐야함**
* **서로 독립적으로 이해하고 논리적으로 추론할 수 있다는 의미에서 낮은 결합도가 달성되도록 노력해야함**
* **높은 수준의 도메인 개념에 따라 모델이 분리되고 그것에 대응되는 코드도 분리될 때까지 모델을 정제해야함**\
  ****
* <mark style="color:red;">**유비쿼터스 언어를 구성하는 것으로 모듈의 이름을 부여해야함**</mark>
* <mark style="color:red;">**모듈과 모듈의 이름은 도메인에 대한 통찰력을 줄 수 있어야함**</mark>

### 5-1. 기민한 모듈

* 모듈은 모델과 함께 발전해야 함
* 이것은 모듈에 대한 리팩터링이 모델과 코드에 대한 리팩터링과 함께 일어난다는 것을 의미함
* 하지만 이러한 리팩터링은 자주 일어나지 않으며 넓은 범위에 걸친 코드를 수정해야함
* 이 같은 변경은 팀의 의사소통을 해칠 수 있음
* 때문에 종종 모듈의 구조와 이름이 현재 클래스가 나타내고 있는 것보다 훨씬 전의 초기 형태의 모델을 반영하기도 함\

* 모듈을 선택할 때 초기에 한 불가피한 실수로 결합도가 높아지면 리팩터링을 수행하기 어려워짐
* 리팩터링을 자주 수행하지 않는다면 상황은 점점 나빠질 것임
* 고통을 꾹 참고 문제가 있는 부분의 모듈을 재조직해야만 문제를 해결할 수 있음
* 이때 모듈을 리팩터링하는 데 소요되는 작업을 최소화하고 다른 개발자들과 의사소통할 때 발생하는 혼란을 최소화하는 방법을 모색해야함

## 6. 모델링 패러다임

* 모델-주도 설계는 채택한 모델링 패러다임과 조화를 이루기 위해 구현 기술의 지원을 필요로함
* 여러 모델링 패러다임 중 객체지향 패러다임이 우세한 경향이 있음

{% hint style="info" %}
에릭 에반스가 DDD를 집필한 시점에는 객체지향 설계가 가장 지배적인 패러다임이라고 표현하였음
{% endhint %}

### 6-1. 객체 패러다임이 지배적인 이유

> 책이 쓰여졌던 시점에서 즉, 20년전 객체 패러다임이 지배적이었던 이유에 대해 얘기하는 장이므로 별도로 정리하지 않음

### 6-2. 객체 세계에서 객체가 아닌 것들

* 도메인 모델이 반드시 객체 모델이어야 하는 것은 아님
* 도메인의 구성요소 마다 더 잘 어울리는 패러다임이 있을 수 있음
* 문제 도메인의 상당 부분이 다른 패러다임에서 훨씬 더 자연스럽게 표현된다면 패러다임을 완전히 교체하는 것이 맞을지도 모름\

* 그러나 도메인의 주된 부분이 다른 패러다임에 더 적합해 보일 때는, 각 모델에 어울리는 패러다임을 혼용하는 것이 나을 수 있음
* 만약 상호의존성이 적다면 다른 패러다임의 하위 시스템을 캡슐화할 수도 있음
  * 예) 단순히 객체에 의해 호출되기만 하는 복잡한 수학 계산
* 그러나 어떤 경우에는 갖자기 측면이 서로 얽히기도 함\

* 패러다임을 혼합하는 것은 개발자에게 개념에 따라 적합한 모델링 형식을 선택할 수 있는 선택지를 줌
* 더욱이 대부분의 시스템에서는 관계형 데이터베이스와 같이 비객체 인프라스트럭처를 사용해야함
* 그러나 여러 패러다임에 걸친 응집력 있는 모델을 만드는 것은 쉽지 않음
* 개발자가 소프트웨어에 포함된 응집력 있는 모델을 분명하게 볼 수 없다면 모델-주도 설계가 사라질 수 있음

### 6-3. 패러다임이 혼재할 때 모델-주도 설계 고수하기

* 흔히 성공적으로 모델링되기도 하지만 규칙을 객체로 캡슐화하면, 전체 시스템에 걸쳐 전역적인 규칙을 적용하기가 부자연스러워짐
* 룰 엔진 기술이 매력적인 이유는 룰 엔진에서 규칙을 정의하는 더욱 자연스러운 방식을 제공하여, 룰 패러다임을 객체 패러다임에 효과적으로 녹아들게 함\

* 그러나 사람들이 룰 엔진에서 기대했던 바를 항상 얻는 것은 아님
* 또한 두 가지 구현 환경 간에 오가는 모델 개념의 관계성을 자연스럽게 보여주지 못하는 경우도 있음
* 그러한 제품에서 공통적으로 얻게 되는 결과 중 하나는 바로 애플리케이션이 두 개로 쪼기진다는 것
* 하나는 객체를 이용한 정적 데이터 저장 시스템이며, 다른 하나는 객체 모델에 대한 연결을 거의 모두 잃어버린 주먹구구식의 규칙 처리 애플리케이션임\

* 규칙을 다루는 중에 모델의 관점에서 사고를 지속하는 것이 중요함
* 팀에서는 두 가지 구현 패러다임에서 모두 작용할 수 있는 모델을 찾아야함
* 이렇게 하기가 쉽지는 않지만 룰 엔진이 구현의 표현력을 풍부하게 한다면 가능할 것임
* 그렇지 않으면 데이터와 규칙 간의 연관관계가 단절됨
* 그러면 엔진 상의 규칙은 결국 도메인 모델의 개념적 규칙이라기 보다는 자그마한 프로그램에 훨씬 가까워짐
* 규칙과 객체 간의 관계가 긴밀하고 명확하다면 두 부분의 의미는 계속 유지됨\

* 각 부분을 함께 유지하는 가장 효과적인 수단은 완전히 이질적인 모델을 통합할 수 있는 확고한 유비쿼터스 언어임
* 유비쿼터스 언어에 포함된 명칭들을 두 환경에 일관되게 적용하고 활용한다면 두 환경 사이에 벌어진 틈을 메우는 데 도움이될 수 있음
* 본 절의 목표 역시 모델-주도 설계를 굳이 포기할 필요가 없으며 그것을 유지하는 노력이 가치 있음을 보여주는 데 있음\

* 모델-주도 설계가 객체지향일 필요는 없지만 표현력이 풍부한 모델 구성물(객체나 규칙 등)의 구현에 의존하는 것은 **분명**함
* 사용하는 도구가 그와 같은 표현력을 촉진하지 못한다면 사용하는 것을 재고해봐야함
* 표현력이 풍부하지 않은 구현은 패러다임의 이점을 잃어버리게 함

객체가 아닌 요소를 객체지향 시스템에 혼합하기 위한 네 가지 법칙이 있음:

* **구현 패러다임을 도메인에 억지로 끼워 맞추지 않는다** \
  도메인에 관한 사고방식은 반드시 하나만 있는 것이 아니다. 패러다임에 어울리는 모델 개념을 찾는다.
* **유비쿼터스 언어에 의지한다** \
  각종 도구가 서로 엄밀한 관계에 있지 않더라도 언어를 매우 일관되게 사용하면 설계의 각 부분이 갈라지는 것을 방지할 수 있음
* **UML에 심취하지 않는다** \
  간혹 사람들이 UML 다이어그램과 같은 도구에 집착해서 그리기 쉬운 방향으로 모델을 왜곡하곤 한다. 이를테면, UML에 제약조건을 표현하는 기능이 포함돼 있기는 하지만 그것만으로는 충분하지 않다. 다른 그리기 방식이나 간단한 문장으로 설명을 써놓는 편이 도식 방법을 완곡하게 바꾸는 것보다 낫다.
* **회의적이어야 한다** \
  도구가 실제로 제 몫을 하고 있는가? 단순히 어떤 규칙이 있다고 해서 반드시 값 비싼 룰 엔진이 필요한 것은 아니다. 아마도 약간은 덜 깔끔하겠지만 규칙은 객체로 표현할 수 있으며, 복합적인 패러다임은 문제를 터무니없이 복잡하게 만든다.\

* 여러 패러다임이 혼재하는 데서 오는 부담을 떠안기 전에 지배적인 패러다임 내에서 선택 가능한 방안을 샅샅이 살펴봐야함
* 어떤 도메인 개념이 분명한 객체로서 스스로를 드러내지 않더라도 보통 해당 패러다임 내에서 모델링될 수 있음\

* 관계형 패러다임은 패러다임 혼합의 특수한 경우임
* 또한 가장 흔히 접하는 비객체 기술인 관계형 데이터베이스는 다른 구성요소에 비해 객체 모델과 더욱 직접적인 관련이 있음
* 그 이유는 관계형 데이터베이스가 객체를 구성하는 데이터의 영구 저장소 역할을 하기 때문임
* ‘6장, 도메인 객체의 생명주기’에서는 관계형 데이터베이스에 객체 데이터를 저장하는 것을 비롯해 다른 여러 객체의 생명주기와 관련된 문제를 살펴봄
