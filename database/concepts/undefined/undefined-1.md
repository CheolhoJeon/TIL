# 장애와 회복

## 1. 장애의 유형

> 장애의 유형

{% tabs %}
{% tab title="트랜잭션 장애" %}
<mark style="color:blue;">**의미:**</mark> 트랜잭션 수행 중 오류가 발생하여 정상적으로 수행을 계속할 수 없는 상태

<mark style="color:blue;">**원인:**</mark> 트랜잭션의 논리적 오류, 잘못된 데이터 입력, 시스템 자원의 과다 사용 요구, 처리 대상 데이터의 부재 등
{% endtab %}

{% tab title="시스템 장애" %}
<mark style="color:blue;">**의미:**</mark> 하드웨어의 결함으로 정상적으로 수행을 계속할 수 없는 상태

<mark style="color:blue;">**원인:**</mark> 하드웨어 이상으로 메인 메모리에 저장된 정보가 손실되거나 교착 상태가 발생한 경우 등
{% endtab %}

{% tab title="미디어 장애" %}
<mark style="color:blue;">**의미:**</mark> 디스크 장치의 결함으로 디스크에 저장된 데이터베이스의 일부 혹은 전체가 손상된 상태

<mark style="color:blue;">**원인:**</mark> 디스크 헤드의 손상이나 고장 등
{% endtab %}
{% endtabs %}

## 2. 데이터베이스의 저장 연산

### **2-1. 데이터베이스를 저장하는 저장 장치의 종류**

{% tabs %}
{% tab title="휘발성 저장 장치(소멸성)" %}
<mark style="color:blue;">**의미:**</mark> 장애가 발생하면 저장된 데이터가 손실됨

<mark style="color:blue;">**예:**</mark> 메인 메모리 등
{% endtab %}

{% tab title="비휘발성 저장 장치(비소멸성)" %}
<mark style="color:blue;">**의미:**</mark> 장애가 발생해도 저장된 데이터가 손실되지 않음. 단, 디스크 헤더 손상 같은 저장 장치 자체에 이상이 \
발생하면 데이터가 손실될 수 있음

<mark style="color:blue;">**예:**</mark> 디스크, 자기 테이프, CD/DVD 등
{% endtab %}

{% tab title="안정 저장 장치" %}
<mark style="color:blue;">**의미:**</mark> 비휘발성 저장 장치를 이용해 데이터 복사본 여러 개를 만드는 방법으로, 어떤 장애가 발생해도 데이터가 손실되지 않고 데이터를 영구적으로 저장할 수 있음
{% endtab %}
{% endtabs %}

### **2-2. 트랜잭션의 수행을 위해 필요한 데이터 이동 연산**

![](../../../.gitbook/assets/IMG\_0006.PNG)

* 일반적으로 데이터베이스는 비휘발성 저장 장치인 디스크에 상주함
* 저장 장치 간의 데이터 이동 연산은 <mark style="color:blue;">블록(block) 단위로 수행됨</mark>
  * 디스크 블록: 디스크에 있는 블록
  * 버퍼 블록: 메인 메모리에 있는 블록

#### <mark style="color:blue;">디스크</mark>와 <mark style="color:blue;">메인 메모리</mark> 간 데이터 이동 연산

{% tabs %}
{% tab title="input(X)" %}
디스크 블록에 저장되어 있는 데이터 X를 메인 메모리 버퍼 블록으로 이동시키는 연산
{% endtab %}

{% tab title="output(X)" %}
메인 메모리 버퍼 블록에 있는 데이터 X를 디스크 블록으로 이동시키는 연산
{% endtab %}
{% endtabs %}

#### <mark style="color:blue;">메인 메모리</mark>와 <mark style="color:blue;">변수</mark> 간의 데이터 이동 연산

{% tabs %}
{% tab title="read(X)" %}
메인 메모리 버퍼 블록에 저장되어 있는 데이터 X를 프로그램의 변수로 읽어오는 연산
{% endtab %}

{% tab title="write(X)" %}
프로그램의 변수 값을 메인 메모리 버퍼 블록에 있는 데이터 X에 기록하는 연산
{% endtab %}
{% endtabs %}

> **트랜잭션을 데이터 이동 연산을 포함한 프로그램으로 표현한 예**

![](../../../.gitbook/assets/IMG\_0009.PNG)

## **3.** 회복 기법

* <mark style="color:red;">회복의 필요성</mark>
  *   <mark style="color:blue;">어떤 트랜잭션 T를 수행하는 도중에 시스템이 다운되었을 때,</mark> T의 수행 효과가 디스크의 데이터베이스에 일부 \
      반영되었을 수 있음

      \-> 어떻게 T의 수행을 취소하여 원자성을 보장할 것인가?
  *   <mark style="color:blue;">트랜잭션 T가 완료된 직후에 시스템이 다운되면,</mark> T의 모든 갱신 효과가 주기억 장치로부터 디스크에 기록되지 \
      않았을 수 있음

      \->어떻게 T의 수행 결과가 데이터베이스에 완전하게 반영되도록 하여 지속성을 보장할 것인가?
  * 디스크의 헤드 등이 고장 나서 디스크의 데이터베이스를 접근할 수 없다면 어떻게 할 것인가?



* <mark style="color:red;">회복(recovery)</mark>
  * 장애가 발생했을 때, 데이터베이스를 장애가 발생하지 전의 일관된 상태로 복구시키는 것
  * 트랜잭션의 특성을 보장하고, 데이터베이스를 일관된 상태로 유지하기 위해 필수적인 기능
  * 회복 관리자(recovery mananger)가 담당
    * 장애 발생을 탐지하고, 장애가 탐지되면 데이터베이스 복구 기능을 제공함



* 여러 응용이 주기억 장치 버퍼 내의 동일한 데이터베이스 항목을 갱신한 후, 디스크에 기록함으로써 성능을 \
  향상시키는 것이 중요함
  * **버퍼의 내용을 디스크에 기록하는 것을 가능하면 최대한 줄이는 것이 일반적임**
    * 버퍼가 꽉 찼을 때 또는 트랜잭션이 완료될 때, 버퍼의 내용이 디스크에 기록될 수 있음
  * 트랜잭션이 버퍼에는 갱신 사항을 반영했지만 버퍼의 내용이 디스크에 기록되기 전에 고장이 발생할 수 있음



* How??
  * **고장이 발생하기 전에 트랜잭션이 완료 명령을 수행했다면**
    * 회복 모듈은 트랜잭션의 갱신 사항을 <mark style="color:red;">재수행(REDO)</mark>하여 트랜잭션의 갱신이 <mark style="color:blue;">지속성</mark>을 갖도록 해야함
  * **고장이 발생하기 전에 트랜잭션이 완료 명령을 수행하지 못했다면**
    * <mark style="color:blue;">원자성</mark>을 보장하기 위해서 이 트랜잭션이 데이터베이스에 반영했을 가능성이 있는 갱신 사항을 <mark style="color:red;">취소(UNDO)</mark>해야 함

### 3-1. 회복을 위한 연산

#### 데이터베이스 복사본을 만드는 방법

| 방법       | 설명                                                                 |
| -------- | ------------------------------------------------------------------ |
| 로그(log)  | 데이터베이스에서 변경 연산이 실행될 때마다 데이터를 변경하기 이전 값과 변경한 이후의 값을 별도의 파일에 기록하는 방법 |
| 덤프(dump) | 데이터베이스 전체를 다른 저장 장치에 주기적으로 복사하는 방법                                 |

{% hint style="info" %}
데이터베이스 회복의 핵심 원리는 데이터 중복!
{% endhint %}

#### 회복을 위한 기본 연산

| 연산        | 설명                                                                                                 |
| --------- | -------------------------------------------------------------------------------------------------- |
| redo(재실행) | 가장 최근에 저장한 데이터베이스 복사본을 가져온 후, 로그를 이용해 복사본이 만들어진 이후에 실행된 모든 변경 연산을 재실행하여 장애가 발생하기 직전의 데이터베이스 상태로 복구 |
| undo(취소)  | 로그를 이용해 지금까지 실행된 모든 변경 연산을 취소하여 데이터베이스를 원래의 상태로 복구                                                 |

#### 로그 파일

* 데이터를 변경하기 이전의 값과 변경한 이후의 값을 기록한 파일
* 레코드 단위로 트랜잭션 수행과 함께 기록됨
* <mark style="color:red;">로그 레코드</mark>의 종류:

| 로그 레코드                       | 설명                                               |
| ---------------------------- | ------------------------------------------------ |
| \<Ti, start>                 | 트랜잭션 Ti가 수행을 시작했음을 기록                            |
| \<Ti, X, oldValue, newValue> | 트랜잭션 Ti가 데이터 X를 이전 값에서 새로운 값으로 변경하는 연산을 실행했음을 기록 |
| \<Ti, commit>                | 트랜잭션 Ti가 성공적으로 완료되었음을 기록                         |
| \<Ti, abort>                 | 트랜잭션 Ti가 철회되었음을 기록                               |

<details>

<summary>로그 기록 예 - 계좌 잔액이 10,000원인 성호가 계좌 잔액이 0원인 은경에게 5,000원 이체</summary>

![](<../../../.gitbook/assets/Untitled-7 (1).png>)

</details>

#### 데이터베이스 회복 기법

![](../../../.gitbook/assets/IMG\_0007.PNG)

### 3-2. 로그 회복 기법

### 3-3. 검사 시점 회복 기법

### 3-4. 미디어 회복 기법
