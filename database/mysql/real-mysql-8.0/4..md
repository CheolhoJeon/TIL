# 4. 아키텍처

* MySQL 서버는 **MySQL 엔진**과 **스토리지 엔진**으로 구분할 수 있음
* 이번 장에서는 MySQL 엔진과 MySQL 서버에서 제공되는 InnoDB, MyISAM 스토리지 엔진을 구분해서 살펴볼 것임

## 4.1 MySQL 엔진 아키텍처

> 먼저 쿼리 작성 및 튜닝에 필요한 기본적인 MySQL 엔진의 구조를 훑어 본다

* MySQL 서버는 다른 DBMS에 비해 구조가 상당히 독특함
* 이로인해 다른 DBMS에서 가질 수 없는 엄청난 혜택을 누리며, 반대로 다른 DBMS에서는 문제되지 않을 것들이 가끔 문제가 되기도 함

### 4.1.1 MySQL의 전체 구조

<figure><img src="../../../.gitbook/assets/image (3).png" alt="그림 4.1 MySQL 서버의 전체 구조"><figcaption><p>그림 4.1 MySQL 서버의 전체 구조</p></figcaption></figure>

#### 4.1.1.1 MySQL 엔진

MySQL 엔진은 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다

#### 4.1.1.2 스토리지 엔진

* **MySQL 엔진은** 요청된 **SQL 문장을 분석**하거나 **최적화**하는 등 DBMS의 두뇌에 해당하는 처리를 수행하고,
* 실제 데이터를 **디스크 스토리지에 저장**하거나 **디스크 스토리로부터 데이터를 읽어오는** 부분은 **스토리지 엔진이 전담**

#### 4.1.1.3 핸들러 API

* MySQL 엔진의 쿼리실행기에서 데이터를 쓰거나 읽어야 할 때는 각 **스토리지 엔진에 쓰기 또는 읽기를 요청**하는데,
* 이러한 요청을 **핸들러(Handler) 요청**이라 하고, 여기서 사용되는 API를 **핸들러 API**라고 함
* InnoDB 스토리지 엔진 또한 이 핸들러 API를 이용해 MySQL 엔진과 데이터를 주고 받음
* 이 핸들러 API를 통해 얼마나 많은 데이터(레코드) 작업이 있었는지 아래의 명령으로 확인할 수 있음
  * `SHOW GLOBAL STATUS LIKE 'Hadler%'`

### 4.1.2 MySQL 스레딩 구조

<figure><img src="../../../.gitbook/assets/image (13).png" alt=""><figcaption><p>그림 4.2 MySQL의 스레딩 모델</p></figcaption></figure>

* MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며, 크게 **포그라운드(Foreground) 스레드**와 **백그라운드(Background) 스레드**로 구분할 수 있음
* MySQL 서버에서 실행 중인 스레드의 목록을 다음과 같이 performance\_schema 데이터베이스의 threads 테이블을 통해 확인할 수 있음
  * ```
    SELECT thread_id, name, type, processlist_user, processlist_host
    FROM performance_schema.threads ORDER BY type, thread_id;
    ```

<figure><img src="../../../.gitbook/assets/image (2).png" alt=""><figcaption><p>실행 결과(결과의 앞 부분은 제외했다)</p></figcaption></figure>

* 전체 44개의 스레드가 실행 중이며, 그중에서 41개의 스레드가 백그라운드 스레드이고 나머지 3개만 프그라운드 스레드로 표시돼 있음
* 하지만 이 중에서 마지막 'thread/sql/one\_connection' 스레드만 실제 사용자의 요청을 처리하는 포그라운드 스레드임
* 백그라운드 스레드의 개수는 MySQL 서버의 설정 내용에 따라 가변적일 수 있음
* **동일한 이름의 스레드가 2개 이상씩 보이는 것은 MySQL 서버의 설정 내용에 의해 여러 스레드가 작업을 병렬로 처리하는 경우**

#### 4.1.2.1 포그라운드 스레드(클라이언트 스레드)

* 포그라운드 스레드는 최소한 MySQL 서버에 **접속된 클라이언트의 수만큼 존재**하며, **주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리**함
* 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 **스레드 캐시(Thread cache)**로 되돌아감
* **이때 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 함**
* 이때 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 **thread\_cache\_size** 시스템 변수로 설정함



* 포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시가 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리함
* MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만, InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 **버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리함**

{% hint style="info" %}
MySQL에서 사용자 스레드와 포그라운드 스레드는 똑같은 의미로 사용된다. 클라이언트가 MySQL 서버에 접 속하게 되면 MySQL 서버는 그 클라이언트의 요청을 처리해 줄 스레드를 생성해 그 클라이언트에게 할당한다. 이 스 레드는 DBMS의 앞단에서 사용자(클라이언트)와 통신하기 때문에 포그라운드 스레드라고 하며, 사용자가 요청한 작업 을 처리하기 때문에 사용자 스레드라고도 한다.
{% endhint %}

#### 4.1.2.2 백그라운드 스레드

* MyISAM의 경우에는 별로 해당 사항이 없는 부분이지만 InnoDB는 다음과 같이 여러 가지 작업이 백그라운드로 처리됨
  * 인서트 버퍼(Insert Buffer)를 병합하는 스레드
  * 로그를 디스크로 기록하는 스레드
  * InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레
  * 데이터를 버퍼로 읽어 오는 스레드
  * 잠금이나 데드락을 모니터링하는 스레



* 이 중에서 가장 중요한 것은 **로그 스레드(Log thread)**와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리하는 **쓰기 스레드(Write thread)**일 것
* MySQL 5.5 버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 2개 이상 지정할 수 있게 됐으며,
* **innodb\_write\_io\_threads**와 **innodb\_read\_io\_threads** 시스템 변수로 스레드의 개수를 설정함
* InnoDB에서도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드는 많이 설정할 필요가 없지만,
* **쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 일반적인 내장 디스크를 사용할 때는 2\~4 정도, DAS나 SAN과 같은 스토리지를 사용할 때는 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋음**

****

****



